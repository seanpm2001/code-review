[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tidyteam code review principles",
    "section": "",
    "text": "Welcome\nA code review is a process where someone other than the author of a piece of code examines that code. At Posit, we use code review to maintain the quality of our code and products.\nThis guide serves as a reference for different aspects of the code review process. It is written with the tidyteam in mind, which make up the combination of the tidyverse, tidymodels, and mlops groups, but is generally applicable to a large amount of the software development we do at Posit. The guide is intended to be used as a way to get new developers up to speed on how we perform code review, and to serve as a linkable resource when there are questions about aspects of the code review process.\nWe mostly use GitHub as the hosting platform for our code, so many details of this guide might refer to aspects specific to doing pull requests using GitHub’s tooling. Additionally, we have a number of R packages that facilitate working on R packages and authoring/reviewing pull requests, such as devtools and usethis. In particular, the family of usethis::pr_*() functions are extremely useful for managing pull requests on R packages.\nWe will use the abbreviation PR to mean a pull request, typically on GitHub."
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Tidyteam code review principles",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis guide is a forked and modified version of Google’s code review principles."
  },
  {
    "objectID": "collaboration/index.html",
    "href": "collaboration/index.html",
    "title": "Patterns of collaboration",
    "section": "",
    "text": "Within the tidyteam group, the way we collaborate with colleagues and external contributors is highly dependent on the context of who is working on a particular package, how closely the contributors are working together, and how often that package is updated. A large amount of the advice in this guide is independent of any specific collaboration context, but some aspects, such as the expected turnaround time of a code review, and the level of detail that is expected from a review, is closely tied to it.\nIt is important to keep in mind that package development within the tidyteam group is probably a little different from software development at other companies. Packages often lie dormant for awhile as the core maintainer works on other projects, which means that sometimes PRs take longer to get reviewed than expected. This is typically expected when working with other tidyteam colleagues, but can be surprising to a community member that is submitting their first PR. If you don’t see any recent activity on the main branch of a package, it is likely that the package is dormant, but rest assured that we will eventually get to your PR.\nIn the following sections, we discuss three patterns of collaboration that we use in the tidyteam group which help us to be explicit about our expectations. These patterns act as a guide and reference, rather than something that is set in stone. Developers should feel free to modify the patterns as needed - the most important thing is that you are communicating these expectations to your team and to your larger user base.\nIn other sections of this guide, we reference these three patterns when making a distinction between them is useful.\n\nClose-knit collaboration\nIn a close-knit collaboration, the PR author and PR reviewer are both heavy contributors to a particular package. It is common for them to be in close contact with each other (i.e. over Slack), and they often coordinate with each other to avoid overlapping each other’s work.\nWith this pattern, reviews are typically swift to avoid blocking one another, which means it is particularly important to write focused PRs. Reviews are also in-depth by default, since both the author and reviewer have significant amount of experience with the package, and should communicate with each other if a superficial review is good enough.\nNote that close-knit collaborators aren’t restricted to Posit employees. ggplot2, dtplyr, and dbplyr have a number of core contributors that aren’t employed by Posit that would be considered under this pattern.\n\n\nThe understudy\nAn understudy typically follows a project from afar, generally submitting smaller PRs or doing superficial code review with a focus on API design, unit tests, and documentation. This allows the understudy to stay up to date with a project they may potentially take over in the future.\nWhen an understudy submits a PR, review is typically swift, in-depth, and comes from a core maintainer as long as that maintainer is actively working on that package. Understudy PRs are often smaller in scope, and can occasionally require multiple rounds of review if they aren’t intimately familiar with the specifics of the package they are working on. If both the understudy and reviewer are Posit employees, discussing the review live (i.e. over Zoom) is often very beneficial for the understudy’s overall understanding of the package.\nWhen an understudy reviews a PR, review is expected to be swift, and the PR assigned to the understudy for review should not require an in-depth knowledge of the package. If the understudy isn’t available to review, it is fine to merge the PR without waiting for a review, especially if it is blocking some other work.\nAn understudy may be an intern at Posit, a motivated community member, or another tidyteam member.\n\n\nExternal contributions\nAn external contribution is a PR authored by someone who isn’t a regular contributor to a package. This may be a one-off PR from a community member, but is often another tidyteam member that notices a small bug or feature that is missing from a package they don’t typically work on. For example, I am not a regular contributor to usethis, but noticed a small non-critical bug and sent in a PR for it.\nWhen an external contributor authors a PR, they should not expect an immediate review. If the package is in a dormant state, it is possible that the PR won’t be looked at for weeks or even months at a time. When the reviewer eventually does look at the PR, if they have comments that need to be addressed, then they should feel free to make a judgement call on whether or not to request that the PR author make the changes, or to just finish off the PR themselves. No matter what the reviewer decides, they should thank the author for their contributions.\nIf the external contributor is a Posit employee and the PR fixes a bug or adds a feature that is a blocker for one of their projects, then the PR author should coordinate with the reviewer to ensure that the PR can be reviewed and merged in a timely manner. If the PR is a blocker, it is important for the package maintainer to respect the deadlines of the PR author, even if they aren’t currently working on the package."
  },
  {
    "objectID": "reviewer/index.html",
    "href": "reviewer/index.html",
    "title": "How to review a pull request",
    "section": "",
    "text": "The pages in this section contain recommendations on the best way to do code reviews, based on long experience. All together they represent one complete document, broken up into many separate sections. You don’t have to read them all, but many people have found it very helpful to read the entire set.\nThe other half of this guide is contained within How to author a pull request."
  },
  {
    "objectID": "reviewer/purpose.html#sec-mentoring",
    "href": "reviewer/purpose.html#sec-mentoring",
    "title": "1  The purpose of code review",
    "section": "1.1 Mentoring",
    "text": "1.1 Mentoring\nAt Posit, we believe that code review is an important part of on-boarding new developers. As a reviewer, it is encouraged to leave comments that help an author learn something new. Linking out to sections of the style guide, design guide, or this code review guide are ways to point to a concrete source of truth that the PR author can read to align their contributions with tidyteam standards.\nPair programming is also an excellent way to perform a code review. One way to do this is to have the reviewer live-review a pull request, which often teaches the author what the reviewer looks for when they review PRs, and gives both parties a way to have an immediate discussion about any tricky design points. It is generally useful to document any insights from the pair programming session as a comment in the code review."
  },
  {
    "objectID": "reviewer/aspects.html#sec-design",
    "href": "reviewer/aspects.html#sec-design",
    "title": "2  Aspects of a PR",
    "section": "2.1 Design",
    "text": "2.1 Design\nThe most important thing to cover in a review is the overall design of the PR. Do the interactions of various pieces of code in the PR make sense? Does this change belong in your codebase, or somewhere upstream? Does it integrate well with the rest of your system?\nHopefully, you and the PR author aligned on the design aspect of the PR before they worked on it. If not, it is often worth pausing and having a separate conversation about the overall design rather than directly reviewing their PR, as that conversation might result in the PR being completely rewritten or closed altogether."
  },
  {
    "objectID": "reviewer/aspects.html#functionality",
    "href": "reviewer/aspects.html#functionality",
    "title": "2  Aspects of a PR",
    "section": "2.2 Functionality",
    "text": "2.2 Functionality\nDoes this PR do what the author intended? Is what the author intended good for the users of this code? The “users” are usually both end-users (when they are affected by the change) and developers (who will have to “use” this code in the future).\nMostly, we expect authors to test PRs well-enough that they work correctly by the time they get to code review. However, as the reviewer you should still be thinking about edge cases, trying to think like a user, and making sure that there are no bugs that you see just by reading the code. In R, typical edge cases to watch out for include checking what happens if the user passes in an object of an unexpected type, or what happens if they pass in an object of zero length.\nAn important part of validating the functionality of a PR is trying it out locally. This is particularly important if the PR has a user-facing impact, such as a new function or argument. Within the tidyteam, we generally check out PRs locally using usethis::pr_fetch(<pr-number>). This is a great time to try out edge cases in the code. It also makes it very easy to create a reprex that you can share with the PR author in a GitHub comment if you do find an issue."
  },
  {
    "objectID": "reviewer/aspects.html#complexity",
    "href": "reviewer/aspects.html#complexity",
    "title": "2  Aspects of a PR",
    "section": "2.3 Complexity",
    "text": "2.3 Complexity\nIs the PR more complex than it should be? Check this at every level of the PR—are individual lines too complex? Are functions too complex? “Too complex” usually means “can’t be understood quickly by code readers.” A way to check for this is to try and “run” the function in your head from top to bottom. If it is exceedingly difficult to do this, the PR might be too complex.\nComplexity can also mean that developers are likely to introduce bugs when they try to call or modify that code in the future.\nA particular type of complexity is over-engineering, where authors have made the code more generic than it needs to be, or added functionality that isn’t presently needed by the system. Reviewers should be especially vigilant about over-engineering. Encourage the author to solve the problem they know needs to be solved now, not the problem that the author speculates might need to be solved in the future. The future problem should be solved once it arrives and you can see its actual shape and requirements in the physical universe."
  },
  {
    "objectID": "reviewer/aspects.html#sec-tests",
    "href": "reviewer/aspects.html#sec-tests",
    "title": "2  Aspects of a PR",
    "section": "2.4 Tests",
    "text": "2.4 Tests\nIn general, if a PR fixes a bug or adds a feature, it should be accompanied by a unit test. If there is a corresponding issue or PR on GitHub that is linked to the test, it is useful for forensic purposes to include the issue number in the test description, like:\ntest_that(\"`my_function()` throws an error when given strings (#553)\")\nRecent versions of the RStudio IDE will automatically generate a hyperlink from this issue number to the corresponding URL on GitHub, which makes these extremely valuable for looking up historical context of a particular bug.\nMake sure that the tests in the PR are correct, sensible, and useful. Tests do not test themselves, and we rarely write tests for our tests—a human must ensure that tests are valid.\nTests should also strive to be as minimal as possible. When a user opens an issue with a bug report, chances are that they have included an example that is tailored to their use case, but isn’t a minimal example of the bug in question. When you write a test for the bug fix, it is worth spending time making the example as minimal as possible so it isolates the bug and is easy to understand in the future. Remember that tests have to be maintained too!\nCross-package integration tests are more difficult, but the tidymodels ecosystem accomplishes this using a separate GitHub-only R package named extratests that is run on a daily basis."
  },
  {
    "objectID": "reviewer/aspects.html#sec-naming",
    "href": "reviewer/aspects.html#sec-naming",
    "title": "2  Aspects of a PR",
    "section": "2.5 Naming",
    "text": "2.5 Naming\nDid the author make an attempt to pick names that are consistent with the rest of the codebase? In general, we also prefer longer names that fully describe the functionality rather than shortened names that require special knowledge of special acronyms."
  },
  {
    "objectID": "reviewer/aspects.html#sec-code-comments",
    "href": "reviewer/aspects.html#sec-code-comments",
    "title": "2  Aspects of a PR",
    "section": "2.6 Comments",
    "text": "2.6 Comments\nCode comments are useful when they explain why some code exists, rather than what the code is doing. Useful comments contain information that can’t possibly be in the code, like the reasoning behind a decision. One example of a good code comment is this one which is part of code that powers tidyr::unnest():\n<snip>\n\ncol <- list_unchop(col, ptype = col_ptype)\n\nif (is_null(col)) {\n  # This can happen when both of these are true:\n  # - `col` was an empty list(), or a list of all `NULL`s.\n  # - No ptype was specified for `col`, either by the user or by a list-of.\n  col <- unspecified(0L)\n}\n\n</snip>\nIt describes the exact combination of inputs required for a very rare branch of code to run. Without the context provided by that comment, it can be a little difficult to know why that branch is there. Particularly challenging comments like this one should come with tests that can provide concrete examples of the issue, like these in tidyr.\nNote that comments are different from documentation of functions, which should instead express the purpose of a piece of code, how it should be used, and how it behaves when used."
  },
  {
    "objectID": "reviewer/aspects.html#style",
    "href": "reviewer/aspects.html#style",
    "title": "2  Aspects of a PR",
    "section": "2.7 Style",
    "text": "2.7 Style\nTidyteam R packages follow our style guide. Two packages support this style guide, styler, which allows you to restyle files or packages, and lintr, which performs automated checks to ensure that you conform to the style guide.\nAdmittedly, many of us don’t use these tools religiously. The important thing is that if there is a point of contention about style in a PR, we can point to the style guide to resolve it.\nThe author of the PR should not include major style changes combined with other changes. It makes it hard to see what is being changed in the PR, makes merges and rollbacks more complex, and causes other problems. If the author wants to reformat the whole file, request that they send you just the reformatting as one PR, and then send another PR with their functional changes after that."
  },
  {
    "objectID": "reviewer/aspects.html#consistency",
    "href": "reviewer/aspects.html#consistency",
    "title": "2  Aspects of a PR",
    "section": "2.8 Consistency",
    "text": "2.8 Consistency\nIn some cases, the style guide makes recommendations rather than declaring requirements. In these cases, it’s a judgment call (typically by the reviewer / maintainer) whether the new code should be consistent with the recommendations or the surrounding code.\nConsistency is also heavily related to naming, and the reviewer should ensure that the author has chosen function names, argument names, and local variable names that are consistent with the rest of the codebase. Consistent naming makes code significantly easier to understand, because it lowers your cognitive burden if you know that, say, loc always stands for an integer value corresponding to a vector index. This is particularly helpful in R, since static typing isn’t available to provide this information for you."
  },
  {
    "objectID": "reviewer/aspects.html#sec-documentation",
    "href": "reviewer/aspects.html#sec-documentation",
    "title": "2  Aspects of a PR",
    "section": "2.9 Documentation",
    "text": "2.9 Documentation\nIf a PR changes how users interact with the package, check to see that it also updates any associated documentation. This includes both R package documentation and updating the pkgdown reference index if a new function is added.\nIt is generally also good practice to provide a news bullet in a NEWS.md file that is associated with the change. This is another place where providing the GitHub issue or PR number is useful, like:\n* `my_function()` now checks that `x` is a numeric value (#565).\nFor more on writing good news bullets, see the style guide.\nIf there isn’t a GitHub issue that corresponds to your bug fix or feature, you can be caught in a chicken-and-egg scenario where you’d like a GitHub PR number to link to, but you haven’t opened the PR yet. One way to resolve this is to:\n\nGo ahead and open the PR without the commit changing the NEWS.md file.\nAdd the news bullet and link to the now open PR.\nPush with a commit message like NEWS bullet.\n\nOccasionally it is useful to document internal functions that aren’t seen by users. This can be useful for other developers to reference as they use common internal helpers. One example of this is tidyr:::df_append(), which includes this internal function documentation marked with @noRd:\n#' Append new columns (`y`) to an existing data frame (`x`)\n#'\n#' @details\n#' If columns are duplicated between `x` and `y`, then `y` columns are\n#' silently preferred.\n#'\n#' @param x A data frame.\n#' @param y A named list of columns to append. Each column must be the same size\n#'   as `x`.\n#' @param after One of:\n#'   - `NULL` to place `y` at the end.\n#'   - A single column name from `x` to place `y` after.\n#'   - A single integer position (including `0L`) to place `y` after.\n#' @param remove Whether or not to remove the column corresponding to `after`\n#'   from `x`.\n#'\n#' @returns\n#' A bare data frame containing the columns from `x` and any appended columns\n#' from `y`. The type of `x` is not maintained. It is up to the caller to\n#' restore the type of `x` with `reconstruct_tibble()`.\n#'\n#' @noRd\ndf_append <- function(x, y, after = NULL, remove = FALSE) {\n  # ...\n}"
  },
  {
    "objectID": "reviewer/aspects.html#every-line",
    "href": "reviewer/aspects.html#every-line",
    "title": "2  Aspects of a PR",
    "section": "2.10 Every line",
    "text": "2.10 Every line\nIn the general case, look at every line of code that you have been assigned to review. Some things like data files, generated code, or large data structures you can scan over sometimes, but don’t scan over a human-written function or block of code and assume that what’s inside of it is okay. Obviously some code deserves more careful scrutiny than other code—that’s a judgment call that you have to make—but you should at least be sure that you understand what all the code is doing.\nIf reviewing every line is too hard and is slowing down the review, then you should let the author know and ask them to clarify it (possibly providing suggestions of your own, if possible). This also applies to code that you understand, but it took a long time for you to figure it out (or you had to run it locally to understand it). If you can’t understand the code, it is likely that other reviewers won’t be able to either! Taking a moment to have the author clarify confusing sections of code will help future developers when it is modified further.\nIf you understand the code but you don’t feel qualified to do some part of the review, it is perfectly acceptable (and preferred!) that you let the author know, and suggest that they request a review from another colleague who has more expertise in that area."
  },
  {
    "objectID": "reviewer/aspects.html#context",
    "href": "reviewer/aspects.html#context",
    "title": "2  Aspects of a PR",
    "section": "2.11 Context",
    "text": "2.11 Context\nIt is often helpful to look at the PR in a broad context. Usually the code review tool on GitHub will only show you a few lines of code around the parts that are being changed. Sometimes you have to look at the whole file to be sure that the change actually makes sense. For example, you might see only four new lines being added, but when you look at the whole file, you see those four lines are in a 50-line helper that now really needs to be broken up into smaller functions.\nIt’s also useful to think about the PR in the context of the system as a whole. Is this PR improving the code health of the system or is it making the whole system more complex, less tested, etc.? PRs should always maintain or improve the overall health of the codebase. Most systems become complex through many small changes that add up, so it’s important to prevent even small complexities in new changes.\nSometimes the timing of the PR isn’t right. It is possible that the codebase may need restructuring before a PR can be accepted. You can generally recognize this when the PR has a large number of changes to parts of the codebase that are seemingly unrelated to the purpose of the PR itself. In those cases, it is often worth suggesting that the author submit a few smaller focused PRs first that prepare the codebase for the larger PR. This reduces the complexity of the larger PR, making it easier to understand and faster to review."
  },
  {
    "objectID": "reviewer/aspects.html#good-things",
    "href": "reviewer/aspects.html#good-things",
    "title": "2  Aspects of a PR",
    "section": "2.12 Compliments",
    "text": "2.12 Compliments\nIf you see something nice in the PR, tell the author, especially when they addressed one of your comments in a great way. Code reviews often just focus on mistakes, but they should offer encouragement and appreciation for good practices, as well. It’s sometimes even more valuable, in terms of mentoring, to tell an author what they did right than to tell them what they did wrong."
  },
  {
    "objectID": "reviewer/navigate.html#summary",
    "href": "reviewer/navigate.html#summary",
    "title": "3  Navigating a PR in review",
    "section": "3.1 Summary",
    "text": "3.1 Summary\nNow that you know what to look for, what’s the most efficient way to manage a review that’s spread across multiple files? Here are three steps to tackle most code reviews:\n\nBefore looking at any code, ask yourself if the rationale behind the change make sense.\nLook at the most important part of the change first. Is it well-designed overall?\nLook at the rest of the PR in an appropriate sequence."
  },
  {
    "objectID": "reviewer/navigate.html#sec-broad",
    "href": "reviewer/navigate.html#sec-broad",
    "title": "3  Navigating a PR in review",
    "section": "3.2 Take a broad view of the change",
    "text": "3.2 Take a broad view of the change\nBefore looking at any code, you should familiarize yourself with the GitHub issue / bug report that the PR is resolving, and read over the PR description to better orient yourself. Does this change even make sense? You can save everyone time if the answer is no by stopping the review there and responding with an explanation of why the change isn’t necessary. Ideally, when performing close-knit collaboration, you will have discussed this ahead of time to avoid the author putting in unnecessary work (and feeling bad if their work is rejected). For external contributions, occasionally you do have to reject PRs if they don’t fit the overall design of the codebase. You should do this nicely, thanking them for their contribution, and requesting that next time they open an issue first and ask if we’d accept a PR for that issue, which would have saved them time if we had an opportunity to preemptively say no.\nFor example, you might say: “Looks like you put some good work into this, thanks! However, we’re actually going in the direction of removing the foo() helper that you’re modifying here, and so we don’t want to make any new modifications to it right now. In the future, it is best if you open an issue first to highlight the bug or feature and ask if we’d accept a pull request for it at this time.”\nIf you get more than a few PRs that represent changes you don’t want to make, you should consider re-working your team’s development process or the posted process for external contributors so that there is more communication before PRs are written. It’s better to tell people “no” before they’ve done a ton of work that now has to be thrown away or drastically re-written."
  },
  {
    "objectID": "reviewer/navigate.html#examine-the-main-parts-of-the-pr",
    "href": "reviewer/navigate.html#examine-the-main-parts-of-the-pr",
    "title": "3  Navigating a PR in review",
    "section": "3.3 Examine the main parts of the PR",
    "text": "3.3 Examine the main parts of the PR\nFind the file or files that are the “main” part of this PR. Often, there is one file that has the largest number of logical changes. Ideally, the PR description will point you to this if there is any ambiguity. Look at these major parts first. This helps give context to all of the smaller parts of the PR, and generally accelerates doing the code review. If the PR is too large for you to figure out which parts are the major parts, ask the author to provide a recommended reading order, or ask them to split up the PR into multiple focused PRs.\nIf you see some major design problems with this part of the PR, you should send those comments immediately, even if you don’t have time to review the rest of the PR right now. In fact, reviewing the rest of the PR might be a waste of time, because if the design problems are significant enough, a lot of the other code under review is going to disappear and not matter anyway.\nThis is also a great time to use usethis::pr_fetch() to pull the PR down locally and try it out. Chances are that the main part of the PR has to do with the main UI changes, so this is a nice time to check that the changes in the PR line up with the output you get from running the code locally."
  },
  {
    "objectID": "reviewer/navigate.html#look-through-the-rest-of-the-pr",
    "href": "reviewer/navigate.html#look-through-the-rest-of-the-pr",
    "title": "3  Navigating a PR in review",
    "section": "3.4 Look through the rest of the PR",
    "text": "3.4 Look through the rest of the PR\nOnce you’ve confirmed there are no major design problems with the PR as a whole, try to figure out a logical sequence to look through the files while also making sure you don’t miss reviewing any file. Usually after you’ve looked through the major files, it’s simplest to just go through each file in the order that the code review tool presents them to you. Sometimes it’s also helpful to read the tests first before you read the main code, because then you have an idea of what the change is supposed to be doing.\nFor R code, you can generally ignore the generated documentation files ending in .Rd while reviewing the PR. GitHub will collapse these by default.\nWhile reading through the PR, make sure to keep the aspects of a PR in mind."
  },
  {
    "objectID": "reviewer/speed.html#why",
    "href": "reviewer/speed.html#why",
    "title": "4  Speed of reviews",
    "section": "4.1 Why should code reviews be fast?",
    "text": "4.1 Why should code reviews be fast?\nThe speed of an individual developer is important, but the speed at which a team of developers can produce high quality code is even more important. When code reviews are slow, several things happen:\n\nAuthors start to protest the code review process. If a reviewer only responds every few days, but requests major changes to the PR each time, that can be frustrating and difficult for the author. If the reviewer requests the same substantial changes (changes which really do improve code health), but responds quickly every time the author makes an update, the frustration tends to disappear. Most complaints about the code review process are actually resolved by making the process faster.\nThe velocity of the team as a whole is decreased. Yes, the individual who doesn’t respond quickly to the review gets other work done. However, new features and bug fixes for the rest of the team are delayed by days, weeks, or months as each PR waits for review.\nCode health can be impacted. When reviews are slow, authors are actually incentivized to submit fewer PRs and to make each one larger. If you think that it is going to take days to get a single small change reviewed, you are going to be pressured to include one more thing in your PR just to avoid another multi-day review process. To ensure that each PR only improves the health of the codebase, code review must be fast enough that authors don’t feel hamstrung by it."
  },
  {
    "objectID": "reviewer/speed.html#what-do-we-mean-by-fast",
    "href": "reviewer/speed.html#what-do-we-mean-by-fast",
    "title": "4  Speed of reviews",
    "section": "4.2 What do we mean by “fast”?",
    "text": "4.2 What do we mean by “fast”?\nRather than suggesting average turnaround times for a PR review (such as 2-4 hours), we feel that it is more useful to categorize PRs under different patterns of collaboration. This recognizes the fact that each PR comes with its own context - a time sensitive bug fix that blocks another colleague is going to be reviewed and merged faster than a small typo in a dormant package that isn’t actively being worked on.\nThe most important thing is for the author and reviewer to have similar expectations around the amount of time a PR review may take. If there is confusion around this, the author and reviewer should discuss this with each other, especially if they are both Posit employees, to ensure that they are on the same page about which pattern their style of collaboration falls under (keeping in mind that the patterns can be modified as needed).\nIf you are feeling overwhelmed by the amount of PRs that you are in charge of, it is worth reviewing your PR process. If you have so many PRs to review that you can’t get to your own work, then you might need to distribute the reviews across your team more evenly. Not speaking up when you are overwhelmed by PRs can in turn slow down an entire team!"
  },
  {
    "objectID": "reviewer/speed.html#sec-interruption",
    "href": "reviewer/speed.html#sec-interruption",
    "title": "4  Speed of reviews",
    "section": "4.3 Speed vs Interruption",
    "text": "4.3 Speed vs Interruption\nThere is one time where the consideration of personal velocity trumps team velocity. If you are in the middle of a focused task, such as writing code, don’t interrupt yourself to do a code review. Research has shown that it can take a long time for a developer to get back into a smooth flow of development after being interrupted. So interrupting yourself while coding is actually more expensive to the team than making a PR author wait a bit for a code review. If you want to read more about this, Paul Graham’s post on Maker vs Manager is very good.\nInstead, wait for a break point in your work before you respond to a request for review. This could be when your current coding task is completed, after lunch, returning from a meeting, coming back from the breakroom, etc. Most “deep work” sessions last around 2-3 hours, so batching your code reviews and handling multiple of them at once after a focused session often works well."
  },
  {
    "objectID": "reviewer/speed.html#detailed-review",
    "href": "reviewer/speed.html#detailed-review",
    "title": "4  Speed of reviews",
    "section": "4.4 Detailed review",
    "text": "4.4 Detailed review\nWith all of this discussion about speed, it can be tempting to just do a surface level review and respond with “LGTM.” Resist this temptation! The whole purpose of code review is to ensure that the code health of the code base is improving, and you are unlikely to catch potential bugs with a surface level review.\nPRs vary greatly in their complexity and sufficiently carrying out the review can take a non-trivial amount of time and cognitive effort. In general:\n\nSmall PRs take anywhere from 5-15 minutes and don’t typically require checking the code out locally. This should be the majority of code reviews that tackle small bugs or documentation changes. You should typically be able to “run” the code related to these changes in your head.\nMedium PRs take up to 30 minutes and often involve using usethis::pr_fetch() and exploring the code locally. This typically includes PRs that implement new features or small UI changes.\nLarge PRs can take up to 1 hour, and occasionally even longer. These should be very rare, and are reserved for large refactorings, especially if there are unavoidable behavior changes mixed in. Large PRs are typically undesirable because they slow the velocity of the entire team, so typically the reviewer should ask the author if the PR can be split into multiple smaller focused PRs. If you don’t have time to review a large PR and it can’t be made any smaller, provide some broad comments on the design of the PR, and consider requesting another colleague to take a look."
  },
  {
    "objectID": "reviewer/speed.html#sec-cross-time-zone",
    "href": "reviewer/speed.html#sec-cross-time-zone",
    "title": "4  Speed of reviews",
    "section": "4.5 Cross time zone reviews",
    "text": "4.5 Cross time zone reviews\nDealing with time zone differences can be challenging, but when the author and reviewer are working together closely it is reasonable for the reviewer to ensure that they provide feedback before the author starts work the next day. If more rapid turnaround times are needed, then the author should communicate that with the reviewer and attempt to batch multiple PRs in parallel, or set aside a predetermined time during the day when both the author and reviewer are online for review."
  },
  {
    "objectID": "reviewer/comments.html#sec-courtesy",
    "href": "reviewer/comments.html#sec-courtesy",
    "title": "5  Writing review comments",
    "section": "5.1 Courtesy",
    "text": "5.1 Courtesy\nIn general, it is important to be courteous and respectful while also being very clear and helpful to the author whose code you are reviewing. One way to do this is to be sure that you are always making comments about the code and never making comments about the author. You don’t always have to follow this practice, but you should definitely use it when saying something that might otherwise be upsetting or contentious. For example:\nBad: “Why did you use threads here when there’s obviously no benefit to be gained from concurrency?”\nGood: “The concurrency model here is adding complexity to the system without any actual performance benefit that I can see. Because there’s no performance benefit, it’s best for this code to be single-threaded instead of using multiple threads.”"
  },
  {
    "objectID": "reviewer/comments.html#sec-why",
    "href": "reviewer/comments.html#sec-why",
    "title": "5  Writing review comments",
    "section": "5.2 Explain why",
    "text": "5.2 Explain why\nOne thing you’ll notice about the “good” example from above is that it helps the author understand why you are making your comment. You don’t always need to include this information in your review comments, but sometimes it’s appropriate to give a bit more explanation around your intent, the best practice you’re following (like the design or style guide), or how your suggestion improves code health."
  },
  {
    "objectID": "reviewer/comments.html#sec-guidance",
    "href": "reviewer/comments.html#sec-guidance",
    "title": "5  Writing review comments",
    "section": "5.3 Giving guidance",
    "text": "5.3 Giving guidance\nIn general it is the author’s responsibility to fix a PR, not the reviewer’s. You are not required to do detailed design of a solution or write code for the author.\nThis doesn’t mean the reviewer should be unhelpful, though. In general you should strike an appropriate balance between pointing out problems and providing direct guidance. Pointing out problems and letting the author make a decision often helps the author learn, and makes it easier to do future code reviews. It also can result in a better solution, because the author is typically closer to the code than the reviewer is.\nOne example of this is to simply point out a section of code that confused you, or which took a long time to understand. This isn’t a direct call to action, but prompts the author to take another look at the code of that section to see if it can be further simplified or clarified (like with a why code comment).\nAnother way to demonstrate an issue is to provide the author a reprex that demonstrates that there is still a bug in their PR. The author can then decide how to resolve it.\nHowever, sometimes direct instructions, suggestions, or even code are more helpful. The primary goal of code review is to get the best PR possible. A secondary goal is improving the skills of PR authors so that they require less and less review over time.\nRemember that people learn from reinforcement of what they are doing well and not just what they could do better. If you see things you like in the PR, comment on those too! Examples: author cleaned up a messy algorithm, added exemplary test coverage, or you as the reviewer learned something from the PR. Just as with all comments, include why you liked something, further encouraging the author to continue good practices."
  },
  {
    "objectID": "reviewer/comments.html#github-suggestions",
    "href": "reviewer/comments.html#github-suggestions",
    "title": "5  Writing review comments",
    "section": "5.4 GitHub suggestions",
    "text": "5.4 GitHub suggestions\nFor very small tweaks, like typos or additions to comments, GitHub provides a feature known as suggestions. As a reviewer, you can add suggestions using the workflow shown below, and the author can accept them directly in the GitHub UI and commit them into the PR (which can then pull locally to get everything up to date if they have more work to do).\n\n\n\n\n\n\n\n\n\n\nAs a reviewer, you can add multiple suggestions and the author can batch multiple suggestions into a single commit."
  },
  {
    "objectID": "reviewer/comments.html#sec-label-comment-severity",
    "href": "reviewer/comments.html#sec-label-comment-severity",
    "title": "5  Writing review comments",
    "section": "5.5 Label comment severity",
    "text": "5.5 Label comment severity\nConsider labeling the severity of your comments, differentiating required changes from guidelines or suggestions.\nHere are some examples:\n\nNit: This is a minor thing. Technically you should do it, but it won’t hugely impact things.\nOptional (or Consider): I think this may be a good idea, but it’s not strictly required.\nFYI: I don’t expect you to do this in this PR, but you may find this interesting to think about for the future.\n\nThis makes review intent explicit and helps authors prioritize the importance of various comments. It also helps avoid misunderstandings; for example, without comment labels, authors may interpret all comments as mandatory, even if some comments are merely intended to be informational or optional."
  },
  {
    "objectID": "reviewer/comments.html#sec-approve-with-comments",
    "href": "reviewer/comments.html#sec-approve-with-comments",
    "title": "5  Writing review comments",
    "section": "5.6 Approve with comments",
    "text": "5.6 Approve with comments\nWhen you’ve finished leaving review comments, GitHub provides a number of options for categorizing your review. The most common kind of PR review within the tidyteam group is known as “approved with comments.” It involves leaving a few minor comments on a PR, while also hitting the Approve button on the GitHub review UI:\n\n\n\n\n\nThis gives the PR author permission to merge the PR as soon as they have addressed the comments without needing to request another round of review. This is done when either:\n\nThe reviewer is confident that the author will appropriately address all the reviewer’s remaining comments.\nThe remaining changes are minor and don’t have to be done by the author.\n\nApproving with comments is largely about the experience of the PR author. For new authors that are still being onboarded, it is common for reviewers to use the Comment option instead, which is a signal to the author that they should request another round of review when they have finished addressing your comments. It is important to remember to be patient with new developers; they are going to need multiple rounds of detailed reviews early on, but putting in this extra effort up front tends to lead to faster PRs in the future as the author learns more about what is expected from their PRs."
  },
  {
    "objectID": "reviewer/comments.html#sec-request-changes",
    "href": "reviewer/comments.html#sec-request-changes",
    "title": "5  Writing review comments",
    "section": "5.7 Requesting changes",
    "text": "5.7 Requesting changes\nGitHub also includes a third option when submitting a review, Request changes. This is typically reserved for more drastic changes that absolutely require another round of review. This option is rare to see in close-knit collaboration, when both the author and reviewer are experts, but is somewhat common when the author is an understudy and with external contributions, where the author likely doesn’t have as much expertise as the reviewer."
  },
  {
    "objectID": "reviewer/comments.html#sec-finishing-off-an-external-contribution",
    "href": "reviewer/comments.html#sec-finishing-off-an-external-contribution",
    "title": "5  Writing review comments",
    "section": "5.8 Finishing off an external contribution",
    "text": "5.8 Finishing off an external contribution\nSometimes when we receive external contributions, we decide that rather than leaving comments for the external contributor, it is more efficient for us as the reviewer (and usually package maintainer) to just finish off the PR and merge it for them. This typically happens when we come back to work on a package after letting it lie dormant for a few months, and we find that we have a few PRs from external contributors. Sometimes these PRs can sit for awhile while no one is actively working on the package, and it might not make much sense to leave comments for the PR author weeks after they sent the PR in. Using usethis::pr_fetch() and usethis::pr_push(), you can instead just take over the PR, fix any minor issues, and merge it in. Make sure that if you do this, you also thank the contributor for their contributions!\nIt is also appropriate to inform a PR author that you’ll finish off a PR if you have already gone through 1-2 rounds of PR review and there are still a few minor edits that need to be made before the PR is ready to be merged."
  },
  {
    "objectID": "reviewer/pushback.html#sec-who-is-right",
    "href": "reviewer/pushback.html#sec-who-is-right",
    "title": "6  Handling pushback",
    "section": "6.1 Who is right?",
    "text": "6.1 Who is right?\nWhen an author disagrees with your suggestion, first take a moment to consider if they are correct. Often, they are closer to the code than you are, and so they might really have a better insight about certain aspects of it. Does their argument make sense? Does it make sense from a code health perspective? If so, let them know that they are right and let the issue drop.\nHowever, authors are not always right. In this case, the reviewer should further explain why they believe that their suggestion is correct. A good explanation demonstrates both an understanding of the author’s reply, and additional information about why the change is being requested. Good explanations are additionally reinforced by facts or external official resources like the design or style guide.\nIn particular, when the reviewer believes their suggestion will avoid a drop in code health, then they should continue to advocate for the change if they believe the resulting code quality improvement justifies the additional work requested. On the other hand, if the PR already improves the overall health of the codebase, it isn’t worth arguing every little stylistic point. Code improvements often happen in small steps.\nSometimes it takes a few rounds of explaining a suggestion before it really sinks in. Just make sure to always stay polite and let the author know that you hear what they’re saying, you just don’t agree."
  },
  {
    "objectID": "reviewer/pushback.html#upsetting_developers",
    "href": "reviewer/pushback.html#upsetting_developers",
    "title": "6  Handling pushback",
    "section": "6.2 Upsetting authors",
    "text": "6.2 Upsetting authors\nReviewers sometimes believe that the author will be upset if the reviewer insists on an improvement. Sometimes authors do become upset, but it is usually brief and they become very thankful later that you helped them improve the quality of their code. Usually, if you are polite in your comments, authors actually don’t become upset at all, and the worry is just in the reviewer’s mind."
  },
  {
    "objectID": "reviewer/pushback.html#later",
    "href": "reviewer/pushback.html#later",
    "title": "6  Handling pushback",
    "section": "6.3 Cleaning it up later",
    "text": "6.3 Cleaning it up later\nA common source of push back is that authors (understandably) want to get things done. They don’t want to go through another round of review just to get this PR in. So they say they will clean something up in a later PR, and thus you should approve this PR now. Some developers are very good about this, and will immediately write a follow-up PR that fixes the issue. However, experience shows that as more time passes after an author writes the original PR, the less likely this clean up is to happen. In fact, usually unless the author does the clean up immediately after the present PR, it never happens. This isn’t because the author is irresponsible, but because they have a lot of work to do and the cleanup gets lost or forgotten in the press of other work. Thus, it is usually best to insist that the author clean up their PR now, before the code is in the codebase and “done.”\nNote that PR cleanup is different from the case where a PR exposes a bug that is technically unrelated to that PR. In the spirit of keeping PRs small and focused, in those cases it is best to open an issue with a reproducible example demonstrating the issue, so that it is tracked and can be addressed after merging the current PR."
  },
  {
    "objectID": "reviewer/pushback.html#sec-conflicts",
    "href": "reviewer/pushback.html#sec-conflicts",
    "title": "6  Handling pushback",
    "section": "6.4 Resolving conflicts",
    "text": "6.4 Resolving conflicts\nIn any conflict on a code review, the first step should always be for the author and reviewer to try to come to consensus, based on the contents of this guide.\nWhen coming to consensus becomes especially difficult, it can help to have a face-to-face meeting or a video conference, instead of just trying to resolve the conflict through code review comments. (If you do this, though, make sure to record the results of the discussion as a comment on the PR, for future readers.)\nIf that doesn’t resolve the situation, the next step is to escalate. Often the escalation path leads to having a third team member offer their own review of the review comments, or having a broader team discussion for particularly complicated issues. Don’t let a PR sit around because the author and the reviewer can’t come to an agreement.\nRemember to respect your colleagues even when you disagree. You both want to generate the best results possible, and just happen to have different beliefs about how to get there."
  },
  {
    "objectID": "author/index.html",
    "href": "author/index.html",
    "title": "How to author a pull request",
    "section": "",
    "text": "The pages in this section contain best practices for developers authoring a pull request to be reviewed. These guidelines should help you get through reviews faster and with higher-quality results. You don’t have to read them all, but many people have found it helpful to read the whole set.\nThe other half of this guide is contained within How to review a pull request."
  },
  {
    "objectID": "author/submitting.html#sec-descriptions",
    "href": "author/submitting.html#sec-descriptions",
    "title": "7  Submitting a PR",
    "section": "7.1 Writing PR descriptions",
    "text": "7.1 Writing PR descriptions\nWhen you submit a pull request through GitHub, you are able to include a PR title and a PR description detailing what the pull request is about. Leaving a detailed and useful description is a vital part of ensuring that your reviewer has a successful experience. There are three big reasons why writing a comprehensive PR description is useful:\n\nYou have the opportunity to orient and prepare your reviewer for your PR before they’ve seen any code.\nForcing yourself to describe (in words) how your PR works is actually a great way to check that it is implemented correctly. If you are having trouble describing the PR, it probably needs to be broken down into simpler pieces.\nYou can take advantage of GitHub specific features, including auto-closing issues, referencing related issues, checklists, and commenting on your own PR.\n\nFuture developers will search for your PR based on its description. Someone in the future might be looking for your change because of a faint memory of its relevance but without the specifics handy. If all the important information is in the code and not the description, it’s going to be a lot harder for them to locate your PR.\n\n7.1.1 Orienting your reviewer\n\n7.1.1.1 Title\nThe title of your pull request should be a very short summary of what is being done. Ideally it should be shorter than 72 characters, because this is what appears in version control history summaries and that is the typical limit before the title is truncated. It should be informative enough that future code searchers don’t have to read your PR or its whole description to understand what your PR actually did. That is, the first line should stand alone, allowing readers to skim through code history much faster.\nBad titles typically don’t contain enough context about the problem the PR is trying to solve. “Fix bug” is an inadequate PR title. What bug? What did you do to fix it? Other similarly bad titles include:\n\n“Add patch”\n“Fixes #123”\n“Moving code from A to B”\n“Phase 1”\n“Add convenience functions”\n\nAvoid restating the title of the corresponding issue in the title of the PR. Focus on summarizing what the actual change you made does, rather than what is being fixed.\n\n\n7.1.1.2 Body\nThe body of a PR description should contain the context a reviewer needs to get into a mental state where they can understand your PR. It might include:\n\nA brief description of the problem being solved\nPossible shortcomings of the approach being used\nLinks to other relevant issues (using GitHub features)\nA before/after reprex that shows what the behavior used to be vs the behavior in this PR\nA before/after benchmark (using the bench package)\n\nThe description should give your reviewer an idea of the code they are about to see, even before they’ve looked at it. By outlining any potential shortcomings, you give the reviewer ideas to keep in mind while they look over your code.\nIf your PR closes a complicated issue that involved a large amount of back and forth discussion, it is worth summarizing the outcome of that discussion in the body of the description. This is especially important if the reviewer wasn’t a part of that discussion, since they’d otherwise have to wade through a large amount of comments to understand why this particular implementation was chosen.\n\n7.1.1.2.1 Reading order\nFor large PRs, it can also be useful to suggest a recommended reading order to your reviewer. This might involve looking at one particular function before another, but could also be a suggestion to look at the examples or tests before looking at the implementation itself, if you feel that they would clarify the purpose of the PR.\n\n\n\n\n7.1.2 Examples of good PR descriptions\n\n7.1.2.1 New feature\nThis vctrs PR contains an example of adding a new feature to an existing function. In this case, a new relationship argument was added to vctrs::vec_locate_matches(), a function that underlies dplyr’s joins, like left_join(). In this case, the total number of changed lines was fairly high, but that is mostly due to a combination of having to touch R code, C code, documentation, and adding new tests. The important thing here is that all of the changes are highly connected, and nothing is extraneous.\nThere are a number of things that are useful to point out regarding this PR:\n\nThis was a case where the author felt like the reviewer might not be as “close” to the code as the author was, so a high-level review to look for any structural problems was good enough. Since an in-depth review is the default, the author made sure to mention that a high-level review was fine up near the top of the description.\nThe description enumerates the possible options for relationship, along with giving examples of how it would directly tie into dplyr (i.e. providing broader context outside just this PR), and inline code examples. This gives the reviewer as much context as possible up front, and creates an extremely useful history to look back on if the PR ever needs to be revisited.\nThe author provided a number of inline comments to call out particularly tricky parts of the code that might need more context. In particular, the author brought up one place in the existing code that he found confusing, which the reviewer also agreed was confusing. This was then acted upon in a separate PR (importantly, not in this one, since the change was unrelated).\nThe reviewer brought up a concern of their own, which the author then provided justification for, and the “tie” went to the author since neither party felt strongly about it.\n\n\n\n7.1.2.2 Performance improvement\nThis vctrs PR contains an example of a PR intended to improve the performance of the dictionary data structure used by many functions in that package. If you look at the changed lines of code, there is really only 1 changed line:\nconst double load_adjusted_size = x_size / 0.77;\nChanged to:\nconst double load_adjusted_size = x_size / 0.50;\nThis is an example where even though the number of lines of changed code is very small, the PR itself required a large amount of context and justification. This context doesn’t belong inside the codebase, but is important for the reviewer as they try to understand why this change was made and whether or not it was the right decision. The PR mentions:\n\nOther sources of information justifying the change\nBefore/after benchmarks showing improved performance\nCases where the performance doesn’t improve, and context about why"
  },
  {
    "objectID": "author/submitting.html#sec-github-features",
    "href": "author/submitting.html#sec-github-features",
    "title": "7  Submitting a PR",
    "section": "7.2 GitHub features",
    "text": "7.2 GitHub features\n\n7.2.1 Closes\nIn the description body, it is useful to mention what issue is closed or fixed by this PR. Specifically, if you mention Closes #545 or Fixes #545 in the body of your PR description, then GitHub will automatically close that issue when the PR is merged. This also helps provide context to both the reviewer and future developers.\nIf you’d like to refer to another issue or PR without closing it, then using terminology like Related to #545 or Part of #545 is a useful way to connect the PR to the issue even if it doesn’t fully resolve it (and GitHub doesn’t do anything special with these phrases).\n\n\n7.2.2 Checklists\nSince GitHub supports Markdown, you can also add checklists to your PR descriptions like this:\n- [ ] Don't forget this\n- [ ] And this\nWhich get rendered in the GitHub UI as:\n\nChecklists are particularly useful in combination with Draft PRs where you might push a partially finished PR to GitHub (to get CI to run, or to ask for advice), but you still have a number of tweaks to make that you don’t want to forget about.\n\n\n7.2.3 Commenting on your own PR\nGitHub allows the PR author to also be their own reviewer. If you open the Files changed menu on GitHub, you can add comments on sections of code that you’ve written, like this:\n\n\n\n\n\nOnce you’ve added your “review,” you can then Comment on the PR:\n\n\n\n\n\nYou won’t be able to Approve, as you can’t approve your own PR.\nCommenting on your own PR is a great way to provide scoped comments inline with the code that they are related to. Comments like this are also great because they start a thread where a reviewer can easily respond to that point without cluttering the rest of the PR. Once the comment has been addressed, it can optionally be marked as resolved by the PR author and collapsed.\nPR comments like this should be reserved for ideas that don’t belong in the codebase itself (i.e. as a code comment). They typically call the reviewer’s attention to something in the PR that they might otherwise miss, or they call out a part of the code that the PR author is a little uncertain about.\nHere are a few real examples of tidyteam members commenting on our own PRs:\n\nImplement dplyr::cross_join()\nRefactoring classes in readxl"
  },
  {
    "objectID": "author/submitting.html#review-before-submitting",
    "href": "author/submitting.html#review-before-submitting",
    "title": "7  Submitting a PR",
    "section": "7.3 Review before submitting",
    "text": "7.3 Review before submitting\nPRs can undergo significant change during review. It can be worthwhile to review a PR description before submitting the PR, to ensure that the description still reflects what the PR does and that it is grammatically correct.\nIf your codebase uses continuous integration to also run checks on your PR, you should also ensure that those are all passing before requesting a review."
  },
  {
    "objectID": "author/submitting.html#sec-request-a-review",
    "href": "author/submitting.html#sec-request-a-review",
    "title": "7  Submitting a PR",
    "section": "7.4 Requesting a review",
    "text": "7.4 Requesting a review\nFor close-knit collaboration and when submitting a PR as an understudy, it is expected that the author will use GitHub’s “request a review” feature to officially ask one or more colleagues to be their reviewer.\n\nThe reviewer you choose depends on their expertise on the part of the codebase your PR affects. Occasionally, it can be useful to select two reviewers for different purposes - one for high-level API design feedback, and one for a full in-depth review.\nFor external contributions, the author likely won’t have the ability to select a reviewer. In this case, it is expected that the maintainer of the package will review the PR when they next actively work on it. If the author is a Posit employee and this PR is blocking other work, then the author should reach out to the maintainer (i.e. over Slack) to agree on an expected timeline for the review."
  },
  {
    "objectID": "author/submitting.html#finishing-a-pr",
    "href": "author/submitting.html#finishing-a-pr",
    "title": "7  Submitting a PR",
    "section": "7.5 Finishing a PR",
    "text": "7.5 Finishing a PR\nAfter you have handled the comments from your reviewer, the PR can get merged in a variety of ways, depending on the collaboration pattern being used.\nFor close-knit collaboration and when working as an understudy, the PR author is typically expected to merge the PR after receiving approval from the reviewer and addressing all comments. After approval is received, the author is no longer required to wait on further feedback from the reviewer before merging.\nFor external contributions, the author likely does not have permission to merge the PR. Instead, it is expected that the reviewer (who is likely also someone with commit rights) will merge the PR for you after all comments have been addressed. Depending on the circumstances, the reviewer may also finish off the PR for you.\nGitHub provides various options for actually merging the PR:\n\n\n\n\n\nMost of the time, we use Squash and merge, which collapses all of the commits into a single commit that gets merged into the main branch. Because of this, we typically don’t care what the commit history of the actual PR looks like, because it will likely be collapsed anyways.\nIf the commit history of the PR has been purposefully structured in a meaningful way, we may also use Create a merge commit to retain the full history.\nAfter the PR has been merged, usethis::pr_finish() can be used to delete the local (and possibly remote) PR branch and switch back to the default branch."
  },
  {
    "objectID": "author/submitting.html#sec-draft-pr",
    "href": "author/submitting.html#sec-draft-pr",
    "title": "7  Submitting a PR",
    "section": "7.6 Draft PRs",
    "text": "7.6 Draft PRs\nIf you aren’t quite ready to submit your PR for a full review, but still want to have it up on GitHub (for CI purposes, perhaps), then you can open a Draft PR. When a PR is in draft form, this is a signal to your collaborators that they don’t need to worry themselves with that PR yet.\nDraft PRs are particularly nice for PRs that you want to get into a “final state” (with CI run and a description written), but you’d also like to sleep on it and give it one last self-review on the following day before requesting a review from a colleague. It is amazing how many small bugs and documentation typos you can find after self-reviewing a PR the day after you wrote it! This also saves time for your eventual reviewer, since you’ve improved the quality of the PR before they’ve even taken a look at it.\nA draft PR is also useful if you want to park a proof of concept somewhere, knowing that you will come back and clean it up in the future."
  },
  {
    "objectID": "author/submitting.html#self-reviews",
    "href": "author/submitting.html#self-reviews",
    "title": "7  Submitting a PR",
    "section": "7.7 Self-reviews",
    "text": "7.7 Self-reviews\nWhile this guide mostly focuses on writing PRs with the goal of being reviewed by someone else, it is also useful to create a PR even if no one else is going to review it. This situation typically arises if you are the only one working on a package, or if you are creating a new package undergoing rapid development. Like with draft PRs, opening a PR, sleeping on it, and then rereading it the following day will often reveal bugs or typos that you’ve missed. Functioning as your own reviewer is a great way to practice the principles outlined in this guide, even if you don’t work on a team, and can prepare you for future collaborative work.\nLeaving a detailed PR description for yourself has more benefits than you might think. Two of the three reasons for writing a good description outlined at the beginning of this section still apply - forcing yourself to describe the feature in words and using GitHub’s many features. It also provides valuable historical context if someone else (likely you) needs to come back to this PR months from now to understand why a particular line was implemented a certain way.\nOpening a PR also forces CI to run, giving you a chance to fix any minor issues before merging it into your main branch. Since CI often takes a few minutes to run, it is typically useful to open a PR and then start working on a separate feature while that CI is running. Once the second feature is finished, you can open a PR for that one, then go back to the first PR and merge it in (possibly giving it a self-review before you do so). The usethis::pr_*() family of functions is particularly suited to this workflow. As long as you are careful to avoid merge conflicts, this allows you to efficiently work on multiple features in parallel."
  },
  {
    "objectID": "author/focused.html#sec-what-is-focused",
    "href": "author/focused.html#sec-what-is-focused",
    "title": "8  Focused PRs",
    "section": "8.1 What is a focused PR?",
    "text": "8.1 What is a focused PR?\nIn general, a focused PR is one self-contained change. This means that:\n\nThe PR makes a minimal change that addresses just one thing. This is sometimes just one part of a feature, rather than a whole feature at once. In general it’s better to err on the side of writing PRs that are too small vs. PRs that are too large. Work with your reviewer to find out what an acceptable scope is.\nEverything the reviewer needs to understand the PR is in the PR, the PR’s description, the existing codebase, or a PR they’ve already recently reviewed.\nThe package will continue to work well for its users and developers after the PR is merged.\nThe PR is not so small that its implications are difficult to understand. If you add a new function, you should include usage of the function in the same PR so that reviewers can better understand its intended purpose.\n\nThere are no hard and fast rules about how large is “too large.” 100 lines is usually a reasonable size for a PR, and 1000 lines is usually too large, but it’s up to the judgment of your reviewer. The number of files that a change is spread across also affects its “size.” A 200-line change in one file might be okay, but spread across 50 files would usually be too large.\nKeep in mind that although you have been intimately involved with your code from the moment you started to write it, the reviewer often has no context. What seems like a focused PR to you might be overwhelming to your reviewer. When in doubt, write PRs that are smaller than you think you need to write. Reviewers rarely complain about getting PRs that are too small."
  },
  {
    "objectID": "author/focused.html#sec-why",
    "href": "author/focused.html#sec-why",
    "title": "8  Focused PRs",
    "section": "8.2 Why write focused PRs?",
    "text": "8.2 Why write focused PRs?\nFocused PRs are:\n\nReviewed more quickly. It’s easier for a reviewer to find 5-10 minutes several times to review a single bug fix than to set aside an hour long block to review one large PR that implements many new features. Large PRs also have a negative compounding affect. Reviewers don’t enjoy getting assigned PRs that try to do too many things at once, and often push them off repeatedly in favor of working on other smaller PRs or more interesting features. The result is that an hour long review turns into a two-day long review because of PR dread.\nReviewed more thoroughly. When many separate features are being changed at once, reviewers and authors tend to get frustrated by large volumes of detailed commentary shifting back and forth—sometimes to the point where important points get missed or dropped.\nLess likely to introduce bugs. Since you’re making fewer changes, it’s easier for you and your reviewer to reason effectively about the impact of the PR and determine if a bug has been introduced.\nLess wasted work if they are rejected. If you write a huge PR and your reviewer says that the overall direction is wrong, you’ve wasted a lot of work.\nEasier to merge. Working on a large PR takes a long time, so you will likely have lots of conflicts when you eventually merge because the main branch will be past the original point of your branch.\nEasier to design well. It’s a lot easier to polish the design and code health of a single change than it is to refine all the details of multiple changes at once.\nLess blocking on reviews. Sending self-contained portions of your overall change allows you to continue coding while you wait for your current PR to be reviewed.\n\nNote that reviewers have discretion to reject your change outright for the sole reason of it being too large. Usually they will thank you for your contribution but request that you somehow make it into a series of smaller changes. It can be a lot of work to split up a change after you’ve already written it, or require lots of time arguing about why the reviewer should accept your large change. If you have any doubts about your PR being rejected, you should discuss this with your reviewer ahead of time before you get too far into the PR to ensure that you don’t do any unnecessary work."
  },
  {
    "objectID": "author/focused.html#sec-refactoring",
    "href": "author/focused.html#sec-refactoring",
    "title": "8  Focused PRs",
    "section": "8.3 Separate out refactorings",
    "text": "8.3 Separate out refactorings\nIt’s usually best to do refactorings in a separate PR from feature changes or bug fixes. For example, moving and renaming a function should be in a different PR from fixing a bug in that function. It is much easier for reviewers to understand the changes introduced by each PR when they are separate. It is typically also easier for git to track that you have simply moved a function if you don’t make any behavioral changes in it.\nSmall cleanups such as fixing a local variable name can be included inside of a feature change or bug fix PR, though. You can also include small changes to documentation related to code you are touching. It’s up to the judgment of the reviewer to decide when a refactoring is so large that it will make the review more difficult if included in your current PR."
  },
  {
    "objectID": "author/focused.html#sec-test-code",
    "href": "author/focused.html#sec-test-code",
    "title": "8  Focused PRs",
    "section": "8.4 Add tests",
    "text": "8.4 Add tests\nFocused PRs should include related test code. Remember that focused here refers to the idea of having a single self-contained PR, and not to minimizing the overall line count.\nA PR that adds or changes logic should be accompanied by new or updated tests for the new behavior. Pure refactoring PRs (that aren’t intended to change behavior) should also be covered by tests. If tests for the code you are refactoring don’t exist, you should add them in a separate PR before doing the refactoring. This gives you a concrete way to validate that the behavior is unchanged before and after the refactoring.\nFor more advice on writing good tests, see this chapter of the R Packages book."
  },
  {
    "objectID": "author/focused.html#sec-large-prs",
    "href": "author/focused.html#sec-large-prs",
    "title": "8  Focused PRs",
    "section": "8.5 Large PRs",
    "text": "8.5 Large PRs\nThere are a few situations in which large changes that affect hundreds of lines aren’t as bad:\n\nYou can usually count deletion of an entire file as a single change, because it doesn’t take the reviewer very long to review.\nSometimes a large PR has been generated by an automatic refactoring tool that you trust completely, and the reviewer’s job is just to verify and say that they really do want the change. With that said, the above point about ensuring that the refactored code is also well-tested still applies.\n\nSometimes you will encounter situations not captured by the above points where it seems like your PR has to be large. This is very rarely true. Authors who practice writing focused PRs can almost always find a way to decompose functionality into a series of small changes.\nBefore writing a large PR, consider whether preceding it with a refactoring-only PR could pave the way for a cleaner implementation. Talk to your teammates and see if anybody has thoughts on how to implement the functionality in focused PRs instead.\nIf you discover a new bug while working on your PR, resisting the urge to tackle it in that PR can help your keep your PR focused. Instead, open an issue to track the bug and address it separately.\nIf all of these options fail (which should be extremely rare) then get consent from your reviewers in advance to review a large PR, so they are warned about what is coming. In this situation, expect the review process to take longer, be vigilant about not introducing bugs, and be extra diligent about writing tests."
  },
  {
    "objectID": "author/handling-comments.html#sec-personal",
    "href": "author/handling-comments.html#sec-personal",
    "title": "9  Handling reviewer comments",
    "section": "9.1 Don’t take it personally",
    "text": "9.1 Don’t take it personally\nThe goal of review is to maintain the quality of our packages. When a reviewer provides a critique of your code, think of it as their attempt to help you and the package rather than as a personal attack on you or your abilities. Most of the time, the reviewer is trying to help you grow as a developer.\nSometimes reviewers feel frustrated and they express that frustration in their comments. This isn’t a good practice for reviewers, but as a PR author you should be prepared for this. Ask yourself, “What is the constructive thing that the reviewer is trying to communicate to me?” and then operate as though that’s what they actually said.\nNever respond in anger to code review comments. That is a serious breach of professional etiquette that will live forever in the code review tool. If you are too angry or annoyed to respond kindly, then walk away from your computer for a while, or work on something else until you feel calm enough to reply politely.\nIn general, if a reviewer isn’t providing feedback in a way that’s constructive and polite, explain this to them in person. If you can’t talk to them in person or on a video call, then send them a private message. Explain to them in a kind way what you don’t like and what you’d like them to do differently. If they also respond in a non-constructive way to this private discussion, or it doesn’t have the intended effect, then escalate internally as appropriate."
  },
  {
    "objectID": "author/handling-comments.html#sec-fix-code",
    "href": "author/handling-comments.html#sec-fix-code",
    "title": "9  Handling reviewer comments",
    "section": "9.2 Fix the code",
    "text": "9.2 Fix the code\nIf a reviewer says that they don’t understand something in your code, your first response should be to clarify the code itself. If the code can’t be clarified, add a code comment that explains why the code is there. If a comment seems pointless, only then should your only response be an explanation in the code review tool.\nIf a reviewer didn’t understand some piece of your code, it’s likely other future readers of the code won’t understand either. Writing a response in the code review tool doesn’t help future code readers, but clarifying your code or adding code comments does help them."
  },
  {
    "objectID": "author/handling-comments.html#sec-think-collaboratively",
    "href": "author/handling-comments.html#sec-think-collaboratively",
    "title": "9  Handling reviewer comments",
    "section": "9.3 Think collaboratively",
    "text": "9.3 Think collaboratively\nWriting a PR can take a lot of work. It’s often really satisfying to finally send one out for review, feel like it’s done, and be pretty sure that no further work is needed. It can be frustrating to receive comments asking for changes, especially if you don’t agree with them.\nAt times like this, take a moment to step back and consider if the reviewer is providing valuable feedback that will improve the package. Your first question to yourself should always be, “Do I understand what the reviewer is asking for?”\nIf you can’t answer that question, ask the reviewer for clarification.\nIf you understand the comments but disagree with them, it’s important to think collaboratively, not combatively or defensively:\n\nBad: “No, I’m not going to do that.”\n\n\nGood: “I went with X because of [these pros/cons] with [these tradeoffs]. My understanding is that using Y would be worse because of [these reasons]. Can you help me understand if there is something that I am missing?”\n\nRemember, courtesy and respect should always be a first priority. If you disagree with the reviewer, find ways to collaborate: ask for clarifications, discuss pros/cons, and provide explanations of why your method of doing things is better for the codebase and for users.\nSometimes, you might know something about the users, codebase, or PR that the reviewer doesn’t know. Fix the code where appropriate, and engage your reviewer in discussion, including giving them more context. Usually you can come to some consensus between yourself and the reviewer based on technical facts."
  },
  {
    "objectID": "author/handling-comments.html#sec-resolve-comments",
    "href": "author/handling-comments.html#sec-resolve-comments",
    "title": "9  Handling reviewer comments",
    "section": "9.4 Who “resolves” GitHub comments?",
    "text": "9.4 Who “resolves” GitHub comments?\nOn GitHub, there is button for Resolve conversation that appears under a comment thread:\n\n\n\n\n\nThis button will collapse the conversation, essentially marking the comment as “completed.” Both the author and reviewer see this button, so who’s job is it to resolve? Within the tidyteam group, we typically expect the PR author to use the resolve button. One typical workflow is to add a thumbs-up emoji or a comment saying that you have handled their comment, and to then resolve the conversation. If you have a question about their comment that requires further input, then add a comment of your own and leave the thread open. Closing resolved threads can reduce the overall noise in the PR, especially if it goes through multiple rounds of review."
  },
  {
    "objectID": "author/handling-comments.html#re-requesting-review",
    "href": "author/handling-comments.html#re-requesting-review",
    "title": "9  Handling reviewer comments",
    "section": "9.5 Re-requesting review",
    "text": "9.5 Re-requesting review\nIf your reviewer has used the Comment or Request Changes button in the GitHub UI, then they expect that you will re-request a review after you have addressed all of their comments.\nFor external contributions where you might not be able to request a review, it is polite to add a comment tagging the reviewer stating that you have finished incorporating their suggestions."
  },
  {
    "objectID": "author/handling-comments.html#resolving-conflicts",
    "href": "author/handling-comments.html#resolving-conflicts",
    "title": "9  Handling reviewer comments",
    "section": "9.6 Resolving conflicts",
    "text": "9.6 Resolving conflicts\nIf you are having difficulty coming to an agreement with your reviewer, try the advice in the reviewer section on conflicts."
  }
]